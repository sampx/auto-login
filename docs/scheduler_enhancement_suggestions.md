# 任务调度引擎优化建议

本文档基于对现有 `scheduler_engine.py` 和 `scheduler_api.py` 的代码分析,提出了一系列可行的功能增强和优化建议,旨在提升调度引擎的健壮性、可观测性和用户体验。

## 1. 实时状态反馈与可见性 (高优先级)

- **当前问题**:
  - Web 界面目前仅能展示任务的“启用/禁用”状态和“下次运行时间”。
  - 无法直观地判断一个任务**当前是否正在运行**。当一个耗时较长的任务被触发后,用户无法感知其执行状态,只能通过查看日志来推断。

- **优化建议**:
  - **后端**:
    - 在 `SchedulerEngine` 中为每个任务增加一个实时状态字段,例如 `current_status`,其值可以是 `idle` (空闲)、`running` (运行中)、`success` (上次成功)、`failed` (上次失败)。
    - 当任务开始执行时,将其状态更新为 `running`。
    - 当任务执行结束时,根据结果更新其状态为 `success` 或 `failed`。
  - **API**:
    - 在 `GET /api/scheduler/tasks` 接口返回的数据中,为每个任务增加 `current_status` 字段。
  - **前端**:
    - 在任务列表界面上,根据 `current_status` 字段为任务添加醒目的视觉提示。例如:
      - **运行中**: 显示一个旋转的加载图标或“运行中”的徽章。
      - **上次成功**: 显示一个绿色的对勾图标。
      - **上次失败**: 显示一个红色的叉号图标。

## 2. 任务执行历史记录

- **当前问题**:
  - 系统只记录了任务的输出日志,但没有一个结构化的执行历史。
  - 用户无法方便地查看一个任务过去的执行情况,例如:
    - 历史运行时间点。
    - 每次执行的成功/失败状态。
    - 每次执行的具体耗时。

- **优化建议**:
  - **后端**:
    - 将每次的 `TaskExecution` 执行记录持久化。可以选择:
      - **SQLite 数据库**: 创建一个简单的 `task_history` 表来存储记录,这是最可靠的方案。
      - **JSON 日志文件**: 为每个任务创建一个 `.history.json` 文件来追加记录。
    - 增加一个新的 API 端点,例如 `GET /api/scheduler/tasks/<task_id>/history`,用于分页查询指定任务的执行历史。
  - **前端**:
    - 在每个任务卡片上增加一个“历史记录”按钮。
    - 点击按钮后,弹出一个模态框,以列表形式清晰地展示该任务最近的执行记录(执行时间、状态、耗时等)。

## 3. 任务依赖功能 (DAG)

- **当前问题**:
  - `Task` 数据类中虽然已经定义了 `task_dependencies` 字段,但后端的调度逻辑并未实现此功能。
  - 无法配置任务之间的依赖关系,例如“任务 B 必须在任务 A 成功后才能执行”。

- **优化建议**:
  - **后端**:
    - 在 `SchedulerEngine` 中实现任务依赖处理逻辑。
    - 当一个任务成功执行后,检查是否有其他任务依赖于它。
    - 如果有,立即触发被依赖任务的执行(可以放入一个执行队列中)。
    - 需要处理循环依赖问题,确保不会造成死循环。
  - **前端**:
    - 在任务创建/编辑界面上,允许用户通过一个下拉列表或多选框来选择其依赖的前置任务。

## 4. 并发与队列管理

- **当前问题**:
  - `APScheduler` 的 `max_instances=1` 配置可以防止同一任务的多个实例并发运行。
  - 但如果一个任务因为上一次执行尚未完成而被调度器跳过 (misfired),用户对此是无感知的。

- **优化建议**:
  - **后端**:
    - 监听 `APScheduler` 的 `EVENT_JOB_MISSED` 事件。
    - 当任务被跳过时,在系统日志中记录一条明确的警告信息,并可以在任务的 `current_status` 中反映出来(例如,`skipped`)。
  - **前端**:
    - (高级功能)可以考虑为任务增加一个“排队中”的状态。如果任务触发时发现前一个实例仍在运行,则在界面上进行明确提示。

## 5. 配置安全性与健壮性

- **当前问题**:
  - `tasks/config.json` 文件如果被手动修改错误(例如,JSON 格式损坏、字段类型错误),可能导致整个调度引擎启动失败或运行时异常。

- **优化建议**:
  - **后端**:
    - 引入 `JSON Schema` 或使用 `Pydantic` 等库对任务配置进行严格的校验。
    - 在加载 `tasks/config.json` 文件时,以及通过 API 创建/更新任务时,都使用 Schema 进行验证。
    - 如果验证失败,应拒绝加载或保存,并返回清晰的错误信息,而不是让程序崩溃。

## 6. 统一的日志管理与自动回转

- **当前问题**:
  - 当前设计要求任务脚本 (`task_exec`) 自己负责写入日志文件, `task_log` 参数仅仅是告知脚本应该写到哪里。
  - 这增加了任务脚本的开发复杂度,开发者必须在脚本中自行实现文件日志记录逻辑。
  - 日志文件会无限增长,没有自动回转和清理机制,长期运行会占用大量磁盘空间。

- **优化建议**:
  - **核心思想**: 调度引擎应全面接管日志处理。任务脚本只需将所有日志信息打印到标准输出 (`stdout`) 和标准错误 (`stderr`),由引擎负责捕获并写入文件。
  - **后端 (`TaskExecutor`)**:
    - 修改 `execute_task` 方法,实时捕获 `subprocess` 的 `stdout` 和 `stderr` 流。
    - 调度引擎将捕获到的输出,实时写入由 `task_log` 指定的日志文件中。这样, `task_log` 字段对任务脚本本身将是透明的。
    - 移除向子进程传递 `TASK_LOG` 环境变量的逻辑。
  - **日志自动回转**:
    - 使用 Python 内置的 `logging.handlers.TimedRotatingFileHandler` 来管理任务日志。
    - 为每个任务配置一个独立的 `logger` 实例,并关联一个 `TimedRotatingFileHandler`。
    - **配置策略**:
      - **回转周期 (`when`)**: 设置为 `D` 或 `midnight`,实现日志文件每天自动分割。
      - **保留数量 (`backupCount`)**: 设置为 `3`,自动保留最近 3 天的日志文件,旧的日志会被自动删除。
  - **带来的好处**:
    - **简化任务开发**: 开发者编写任务脚本时,不再需要关心日志文件的写入、路径等问题,只需使用 `print()` 或 `echo` 即可输出日志,极大降低了开发门槛。
    - **日志管理标准化**: 所有任务的日志都由引擎统一管理,具备一致的格式、回转和保留策略,便于维护。
    - **可靠性提升**: 确保任务的所有输出(包括正常信息和错误信息)都能被完整捕获,不会因为脚本自身的日志配置问题而丢失信息。

## 7. 规范化任务退出码与智能重试

- **核心思想**:
  为任务脚本制定一套标准的退出码 (Exit Code) 规范,使调度引擎能够区分不同类型的“失败”,并据此采取不同的策略,特别是重试策略。

- **退出码规范**:
  - `0`: **执行成功 (Success)**。任务完成了其预期的技术和业务目标。
  - `1`: **业务失败 (Business Failure)**。脚本本身运行正常,没有出现程序崩溃或技术异常,但业务目标未达成。这是一种**可预期的失败**,不应触发重试。
    - *示例*: 登录脚本因密码错误而失败; 数据抓取脚本未找到目标信息。
  - `2`: **技术失败 (Technical Failure)**。脚本在执行中遇到意外的系统级或程序级错误。这是一种**非预期的失败**,应该触发重试。
    - *示例*: 抛出未捕获的异常; 网络连接超时; 数据库连接失败。

- **引擎侧实现逻辑**:
  - **状态扩展**: 在 `TaskExecution` 模型中,将 `status: "failed"` 细化为 `technical_failure` 和 `business_failure`。
  - **执行器 (`TaskExecutor`) 改造**:
    - 在 `execute_task` 方法中,根据 `process.returncode` 来设置 `TaskExecution` 的最终状态:
      - `returncode == 0` -> `status = "success"`
      - `returncode == 1` -> `status = "business_failure"`
      - `returncode` 为任何其他非零值 (包括 `2`) -> `status = "technical_failure"`
      - 任务执行超时也应归类为 `technical_failure`。
  - **调度器 (`_execute_task_wrapper`) 重试逻辑改造**:
    - 修改重试循环的判断条件,**仅当 `execution.status` 为 `technical_failure` 时才进行重试**。
    - 如果状态是 `success` 或 `business_failure`,则应立即停止重试。

- **带来的好处**:
  - **智能重试**: 避免对可预期的业务失败进行无效重试,节省系统资源,防止因重试导致账户锁定等问题。
  - **清晰的失败分类**: 运维人员可以从任务状态中快速判断问题根源,极大提高诊断效率。
  - **完善开发规范**: 为任务开发者提供了一套清晰、有效的开发契约,提升系统整体的稳定性和可维护性。

## 8. 建立任务脚本开发指南与标准模板

- **当前问题**:
  - 随着引擎功能越来越强大,如何让普通开发者快速、正确地编写出能与引擎高效协同的任务脚本,成了一个新问题。
  - 缺少一份官方的“最佳实践”文档和可供参考的模板,特别是对不同脚本语言(如 Python 和 Shell)的支持说明不够清晰。

- **优化建议**:
  - 创建一份名为 `task_script_development_guide.md` 的开发指南,详细说明日志、退出码、环境变量等核心开发约定,并为 Python 和 Shell 脚本提供独立的示例说明。
  - 创建两个标准示例脚本,作为新任务开发的官方模板:
    - `tasks/example_task_script.py` (Python 版本)
    - `tasks/example_task_script.sh` (Shell 版本)

## 9. 高度可配置的通知系统

- **核心思想**: 将通知功能解耦成一个通用的、基于规则的事件处理系统。引擎负责在正确的时间点,根据正确的条件触发“通知事件”,而具体的通知方式(邮件、Webhook 等)只是事件的消费者。

- **配置规范 (`task_notify` 字段)**: `task_notify` 应为一个**规则列表(数组)**,每个规则对象包含:
  - `name` (string): 规则名称,用于界面展示 (e.g., "技术失败时立即告警给管理员")。
  - `enabled` (boolean): 是否启用此规则。
  - `triggers` (array of strings): 触发通知的事件类型,与退出码规范联动。
    - `success`: 任务执行成功 (`exit 0`)。
    - `business_failure`: 任务业务失败 (`exit 1`)。
    - `technical_failure`: 任务技术失败 (`exit 2` 或其他)。
    - `timeout`: 任务执行超时。
  - `threshold` (integer, default: 1): 触发通知所需的**连续**事件发生次数。例如,设置为 `3` 和 `triggers: ["technical_failure"]` 意为“当任务**连续**第 3 次发生技术失败时”才发送通知。
  - `channels` (array of objects): 定义通知发送的渠道,允许一条规则通过多种方式发送。

- **渠道对象 (`channels`) 设计 (以 Email 为例)**:
  ```json
  {
    "type": "email",
    "recipients": ["admin@example.com", "dev-on-call@example.com"],
    "subject_template": "任务告警: {{task_name}} 执行失败!",
    "body_template": "任务 [{{task_id}}] 在 {{execution_end_time}} 执行失败。\n状态: {{execution_status}}\n连续失败次数: {{threshold_count}}\n\n最后日志输出:\n---\n{{execution_log_tail}}\n---"
  }
  ```

- **内容模板变量**: 引擎在发送通知时,应提供以下变量供模板使用:
  - `{{task_id}}`, `{{task_name}}`, `{{execution_status}}`, `{{execution_start_time}}`, `{{execution_end_time}}`, `{{execution_duration}}`, `{{threshold_count}}`, `{{execution_log_tail}}` (最后 N 行日志)。